<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-10-19 Sat 16:08 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Note</title>
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  pre.src-C\+\+:before { content: 'C++'; }
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="https://orgmode.org/worg/style/worg.css"/>

<script src="https://orgmode.org/org-info.js">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
// @license-end
</script>

<script>
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
org_html_manager.set("TOC_DEPTH", "2");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "2");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
// @license-end
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Note</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgb1cf556">1. categorical logic and type theory</a>
<ul>
<li><a href="#orgf34f381">1.1. chapter 0</a></li>
<li><a href="#org4e7df6a">1.2. 0.1 Logic, type theory, and fibred category theory</a>
<ul>
<li><a href="#org1d9e668">1.2.1. part one: logic over a type theory</a></li>
<li><a href="#org809da52">1.2.2. part two: type theory</a></li>
<li><a href="#org51f8a74">1.2.3. part three: fibred category</a></li>
<li><a href="#org124d848">1.2.4. part four: categorical phenomena</a></li>
<li><a href="#orgd9146e7">1.2.5. part five: categorical structures</a></li>
<li><a href="#orga6a181b">1.2.6. part six: what this book is not</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgb1cf556" class="outline-2">
<h2 id="orgb1cf556"><span class="section-number-2">1.</span> categorical logic and type theory</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgf34f381" class="outline-3">
<h3 id="orgf34f381"><span class="section-number-3">1.1.</span> chapter 0</h3>
<div class="outline-text-3" id="text-1-1">
<p>
This introductory chapter is divided into two parts. It first discusses some generalities concerning logic, type theory and category theory, and describes some themes that will be developed in this book. It then continues with a description of the (standard) logic and type theory of ordinary sets, from the perspective of fibred category theory&#x2013;typical of this book. This description focuses on the fundamental adjunctions that govern the various logical and type theoretic operations.
</p>
</div>
</div>
<div id="outline-container-org4e7df6a" class="outline-3">
<h3 id="org4e7df6a"><span class="section-number-3">1.2.</span> 0.1 Logic, type theory, and fibred category theory</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org1d9e668" class="outline-4">
<h4 id="org1d9e668"><span class="section-number-4">1.2.1.</span> part one: logic over a type theory</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
A logic is always a logic over a type theory. This statement sums up our approach to logic and type theory, and forms an appropriate starting point. It describes a type theory as a “theory of sorts”, providing a domain of reason-ing for a logic. Roughly, types are used to classify values, so that one can distinguish between zero as a natural number <img src="./ltximg/org-tex-8fc6f849c59fa52ea97551448c084dbedba95183.svg" alt="\(0\colon \mathbb{N}\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> and zero as a real number <img src="./ltximg/org-tex-bef5461a72e9d236e18392f294fcc191c167dd0b.svg" alt="\(0\colon\mathbb{R}\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, and between addition <img src="./ltximg/org-tex-556ba0193c0757320508d6fab6751c97b4d3e6b1.svg" alt="\(+ \colon \mathbb{N}\times\mathbb{N}\to\mathbb{N}\)" style="height: 0.8551em; vertical-align: -0.1309em; display: inline-block" class="org-latex org-latex-inline" /> on natural numbers and addition <img src="./ltximg/org-tex-c853927f45320f87b941cd897dd27f948fab5469.svg" alt="\( + \colon \mathbb{R}\times\mathbb{R}\to \mathbb{R}\)" style="height: 0.8551em; vertical-align: -0.1309em; display: inline-block" class="org-latex org-latex-inline" /> on real numbers. In these examples we use atomic types <img src="./ltximg/org-tex-e530bd53b422c5732f5283f843c3b56889225212.svg" alt="\(\mathbb{N}\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> and <img src="./ltximg/org-tex-d4485921c3aa28e1d501fc38b7a70c3fd80740e7.svg" alt="\(\mathbb{R}\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> and composite types <img src="./ltximg/org-tex-2f00e9535737230203b75ee9eab095ef4a66f548.svg" alt="\(\mathbb{N}\times\mathbb{N}\to\mathbb{N}\)" style="height: 0.8551em; vertical-align: -0.1309em; display: inline-block" class="org-latex org-latex-inline" /> and <img src="./ltximg/org-tex-11c6e325695c16016d864d516d24887f8aa19f96.svg" alt="\(\R \times \R \to \R\)" style="height: 0.8551em; vertical-align: -0.1309em; display: inline-block" class="org-latex org-latex-inline" /> obtained with the type constructors <img src="./ltximg/org-tex-4091c0eb70642e11ae64a067530cde7e652f4312.svg" alt="\(\times\)" style="height: 0.7517em; vertical-align: -0.1309em; display: inline-block" class="org-latex org-latex-inline" /> for Cartesian product, and <img src="./ltximg/org-tex-6a166f91f51dbeb5e1426e48f3fb1a183287aa2d.svg" alt="\(\to\)" style="height: 0.4579em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> for exponent (or function space). The relation <img src="./ltximg/org-tex-a14f7d0c993cad87820592ed7e368e052d0a6de5.svg" alt="\(:\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> as in <img src="./ltximg/org-tex-3e202dc9287115fb1d32fec4d4c659dbfc6b8295.svg" alt="\(0\colon \N\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, is the inhabitation relation of type theory. It expresses that <img src="./ltximg/org-tex-25c55a5c0ef7fa2ed412d86467cf82e09b00fb20.svg" alt="\(0\)" style="height: 0.7299em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> is of type <img src="./ltximg/org-tex-e530bd53b422c5732f5283f843c3b56889225212.svg" alt="\(\mathbb{N}\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, i.e. that <img src="./ltximg/org-tex-25c55a5c0ef7fa2ed412d86467cf82e09b00fb20.svg" alt="\(0\)" style="height: 0.7299em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> inhabits <img src="./ltximg/org-tex-e530bd53b422c5732f5283f843c3b56889225212.svg" alt="\(\mathbb{N}\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />. It is like membership <img src="./ltximg/org-tex-247b286a0323d79848b0cea458162f45477a2a94.svg" alt="\(\in\)" style="height: 0.6650em; vertical-align: -0.0875em; display: inline-block" class="org-latex org-latex-inline" /> in set theory, except that <img src="./ltximg/org-tex-247b286a0323d79848b0cea458162f45477a2a94.svg" alt="\(\in\)" style="height: 0.6650em; vertical-align: -0.0875em; display: inline-block" class="org-latex org-latex-inline" /> is untyped, since everything is a set. But a string is something which does not inhabit the type of natural numbers. Hence we shall have to deal with rules regulating inhabitation, like
</p>

<p>
<img src="./ltximg/org-tex-4e1a1a737d9b7786d9f3244b115c839c170398da.svg" alt="\[
\prftree[r]{}
        {}
        {0 \colon \N}\quad
\prftree[r]{}
        {n \colon \N}
        {\texttt{succ}(n)\colon \N}
\]" style="height: 2.6288em; display: block" class="org-latex org-latex-block" />
</p>

<p>
The first rule is unconditional: it has no premises and simply expresses that the term O inhabits the type <img src="./ltximg/org-tex-165ff0a40869b6a1c072070d8c9b43bbc6b07da9.svg" alt="\(\N\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />. The second rule tells that if we know that <img src="./ltximg/org-tex-33445a62a743c0be74c14b17f5ef8190e2a80efe.svg" alt="\(n\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> inhabits <img src="./ltximg/org-tex-165ff0a40869b6a1c072070d8c9b43bbc6b07da9.svg" alt="\(\N\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, then we may conclude that <img src="./ltximg/org-tex-218c9369f9ed5d798ac517ffa8a524be47a58c6a.svg" alt="\(\texttt{succ}(n)\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> also inhabits <img src="./ltximg/org-tex-165ff0a40869b6a1c072070d8c9b43bbc6b07da9.svg" alt="\(\N\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, where <img src="./ltximg/org-tex-0a94b763cf7e6bcb8e5b804becfdcac64422c014.svg" alt="\(\texttt{succ}(-)\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> may be read as successor operation. In this way one can generate terms, like <img src="./ltximg/org-tex-0c2099f7a5e2943fd9c2c766600dd0cc36b63a56.svg" alt="\(\succ(\succ(0)): \N\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> inhabiting the type <img src="./ltximg/org-tex-165ff0a40869b6a1c072070d8c9b43bbc6b07da9.svg" alt="\(\N\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />.
</p>

<p>
In predicate logic one reasons about such terms in a type theory, like in
</p>

<p>
<img src="./ltximg/org-tex-d4ba31951d081015db7081de79c18e18a7f27bca.svg" alt="\[\forall x \colon \N. \exists y\colon \N . y &amp;gt; \succ(x)\]" style="height: 1.5194em; display: block" class="org-latex org-latex-block" />
</p>

<p>
This gives an example of a proposition. The fact that this expression is a proposition may also be seen as an inhabitation statement, so we can write
</p>

<p>
<img src="./ltximg/org-tex-efb27d10bf5332b5b24768b13eda01852f10169b.svg" alt="\[(\forall x \colon \N . \exists y \colon \N . y &amp;gt; \succ(x))\colon \mathsf{Prop}\]" style="height: 1.5194em; display: block" class="org-latex org-latex-block" />
</p>


<p>
using a type Prop of propositions. In this particular proposition there are no free variables, but in predicate logic an arbitrary proposition <img src="./ltximg/org-tex-1e76be9e93f76f43e449b0f151a61b6817165170.svg" alt="\(y\colon \Prop\)" style="height: 0.9695em; vertical-align: -0.2397em; display: inline-block" class="org-latex org-latex-inline" /> may contain free variables. These variables range over types, like in:
</p>

<p>
<img src="./ltximg/org-tex-0e25268d3197e888e4cfba851ff817e7367d1987.svg" alt="\[x &amp;gt; 5 \colon \mathsf{Prop}, \text{ where }x \colon \N \quad \text{or} \quad
x &amp;gt; 5 \colon \mathsf{Prop}, \text{ where } x \colon \R\]" style="height: 1.4649em; display: block" class="org-latex org-latex-block" />
</p>

<p>
We usually write these free variables in a “context", which is a sequence of variable declarations. In the examples the sequence is a singleton, so we write
</p>

<p>
<img src="./ltximg/org-tex-9ae98301ea431b17391ac12b9013b8db607a192b.svg" alt="\[x \colon \N \vdash x &amp;gt; 5 \colon \mathsf{Prop}\quad \text{and} \quad
x \colon \R \vdash x &amp;gt; 5 \colon \mathsf{Prop}\]" style="height: 1.4649em; display: block" class="org-latex org-latex-block" />
</p>

<p>
The turnstile symbol <img src="./ltximg/org-tex-677ff9603b67ec88cfe4e155930c391035bd687b.svg" alt="\(\vdash\)" style="height: 0.7789em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> separates the context from the conclusion: we read the sequent <img src="./ltximg/org-tex-42130dbe03079d5f51180e8815f196263e298eab.svg" alt="\(x\colon \N \vdash x &amp;gt; 5 \colon \mathsf{Prop}\)" style="height: 0.9695em; vertical-align: -0.2397em; display: inline-block" class="org-latex org-latex-inline" /> as: in the context where the variable <img src="./ltximg/org-tex-9ea8917703565f13d2a7c311ca1ce811c9f30b43.svg" alt="\(x\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> is of type <img src="./ltximg/org-tex-165ff0a40869b6a1c072070d8c9b43bbc6b07da9.svg" alt="\(\N\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, the expression <img src="./ltximg/org-tex-6d03b830806774cff429dc0e66002124597f61de.svg" alt="\(x &amp;gt; 5\)" style="height: 0.7682em; vertical-align: -0.0875em; display: inline-block" class="org-latex org-latex-inline" /> is a proposition. Well-typedness is of importance, since if <img src="./ltximg/org-tex-9ea8917703565f13d2a7c311ca1ce811c9f30b43.svg" alt="\(x\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> is a string, then the expression <img src="./ltximg/org-tex-6d03b830806774cff429dc0e66002124597f61de.svg" alt="\(x &amp;gt; 5\)" style="height: 0.7682em; vertical-align: -0.0875em; display: inline-block" class="org-latex org-latex-inline" /> does not make sense (unless one has a different operation <img src="./ltximg/org-tex-926d4fd3751b2a11fb9f0c6d6526695a57aefb60.svg" alt="\(&amp;gt;\)" style="height: 0.6650em; vertical-align: -0.0875em; display: inline-block" class="org-latex org-latex-inline" /> on strings, and one reads '<img src="./ltximg/org-tex-d687fc2a082dbec44ab05f804dd758d54548c2ab.svg" alt="\(5\)" style="height: 0.7299em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />' as a string).
</p>

<p>
This explains what we mean with: a logic is always a logic over a type theory. Underlying a logic there is always a calculus of typed terms that one reasons about. But one may ask: what about single-sorted logic (i.e. single-typed, or untyped, logic) in which variables are thought of as ranging over a single domain, so that types do not really play a role? Then one still has a type theory, albeit a very primitive one with only one type (namely the type of the domain), and no type constructors. In such situations one often omits the (sole) type, since it has no role. But formally, it is there. And what about propositional logic? It is included as a border case: it can be seen as a degenerate predicate logic in which all predicates are closed (i.e. do not contain term variables), so one can see propositional logic as a logic over the empty type theory.
</p>
</div>
</div>
<div id="outline-container-org809da52" class="outline-4">
<h4 id="org809da52"><span class="section-number-4">1.2.2.</span> part two: type theory</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
We distinguish three basic kinds of type theory:
</p>

<ul class="org-ul">
<li>simple type theory (STT);</li>
<li>dependent type theory (DTT);</li>
<li>polymorphic type theory (PTT).</li>
</ul>

<p>
In simple type theory there are types built up from atomic types (like <img src="./ltximg/org-tex-165ff0a40869b6a1c072070d8c9b43bbc6b07da9.svg" alt="\(\N\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, above) using type constructors like exponent <img src="./ltximg/org-tex-6a166f91f51dbeb5e1426e48f3fb1a183287aa2d.svg" alt="\(\to\)" style="height: 0.4579em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, Cartesian product <img src="./ltximg/org-tex-4091c0eb70642e11ae64a067530cde7e652f4312.svg" alt="\(\times\)" style="height: 0.7517em; vertical-align: -0.1309em; display: inline-block" class="org-latex org-latex-inline" /> or coproduct (disjoint union) <img src="./ltximg/org-tex-8f6e69ef262341d594f2c91bf3e494859d2c0fdc.svg" alt="\(+\)" style="height: 0.7517em; vertical-align: -0.1309em; display: inline-block" class="org-latex org-latex-inline" />. Term variables <img src="./ltximg/org-tex-30c42e67cb535f54813cee566a1e287b85aeb6aa.svg" alt="\(x\colon \sigma\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> are used to build up terms, using atomic terms and introduction and elimination operations associated with the type constructors (like tuples and projections for products <img src="./ltximg/org-tex-4091c0eb70642e11ae64a067530cde7e652f4312.svg" alt="\(\times\)" style="height: 0.7517em; vertical-align: -0.1309em; display: inline-block" class="org-latex org-latex-inline" />). Types in simple type theory may be seen as sets, and (closed) terms inhabiting types as elements of these sets. In <code>dependent</code> type theory, one allows a term variable <img src="./ltximg/org-tex-30c42e67cb535f54813cee566a1e287b85aeb6aa.svg" alt="\(x\colon \sigma\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> to occur in another type <img src="./ltximg/org-tex-3dcc7592ea8bf1b91ef4b92da658dea22ae6c974.svg" alt="\(\tau \colon (x)\colon \mathsf{Type}\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" />. This increases the expressive power, for example because one can use in DTT the type <img src="./ltximg/org-tex-b38970cb2cc3974b06363e8d0ade553b70cef532.svg" alt="\(\mathsf{Matrix}(n, m)\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> of <img src="./ltximg/org-tex-f6648be447239a00190b335e8e52af703090377b.svg" alt="\(n \times m\)" style="height: 0.7517em; vertical-align: -0.1309em; display: inline-block" class="org-latex org-latex-inline" /> matrices (say over some fixed field), for <img src="./ltximg/org-tex-9775e0fb6512c55418c5e5a87ab276c23951d339.svg" alt="\(n\colon \N\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> and <img src="./ltximg/org-tex-4f2779a925329ffcf48a523c2f5d70b691575090.svg" alt="\(m\colon \N\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> terms of type <img src="./ltximg/org-tex-165ff0a40869b6a1c072070d8c9b43bbc6b07da9.svg" alt="\(\N\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />. If one thinks of types as sets, this type dependency is like having for each element <img src="./ltximg/org-tex-adb3e08a93fa7190ea044bdd43b1cc8c99bf1dd0.svg" alt="\(i \in I\)" style="height: 0.8063em; vertical-align: -0.0875em; display: inline-block" class="org-latex org-latex-inline" /> of a set <img src="./ltximg/org-tex-790e7dc1cdbf45441d1cb9799b6811b07b04005f.svg" alt="\(I\)" style="height: 0.7680em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, another set <img src="./ltximg/org-tex-73fbe538e4439abe7f9a55c4e2a365ca303b617c.svg" alt="\(X(i)\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" />. One usually writes <img src="./ltximg/org-tex-c4ec85acf1c254126373621a7c08d0e511d92292.svg" alt="\(X_{i} = X(i)\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> and sees <img src="./ltximg/org-tex-5a34b26e29c800ed5338ed4f57ad8adb2ace92ce.svg" alt="\((X_{i})_{i \in I}\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> as an <img src="./ltximg/org-tex-790e7dc1cdbf45441d1cb9799b6811b07b04005f.svg" alt="\(I\)" style="height: 0.7680em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />-indexed family of sets. Thus, in dependent type theory one allows type-indexed-types, in analogy with set-indexed-sets. Finally, in <code>polymorphic</code> type theory, one may use additional type variables <img src="./ltximg/org-tex-3bce569d60cc18a26dcd40d71fce5082e782af8a.svg" alt="\(\alpha\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> to build up types. So type variables <img src="./ltximg/org-tex-3bce569d60cc18a26dcd40d71fce5082e782af8a.svg" alt="\(\alpha\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> may occur inside a type <img src="./ltximg/org-tex-5d4449d59b855497b1692253fcbfa4227d82b57c.svg" alt="\(\sigma(\alpha)\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" />, like in the type <img src="./ltximg/org-tex-71d1dc539ce8247db6929608cb9dd616668c39a7.svg" alt="\(\mathsf{list}(\alpha)\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> of lists of type <img src="./ltximg/org-tex-3bce569d60cc18a26dcd40d71fce5082e782af8a.svg" alt="\(\alpha\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />. This means that one has types, indexed by (or parametrised by) the universe <img src="./ltximg/org-tex-521e75a82af597e429ca811895bd4a7709f8ec4b.svg" alt="\(\mathsf{Type}\)" style="height: 0.9695em; vertical-align: -0.2397em; display: inline-block" class="org-latex org-latex-inline" /> of all types. In a set theoretic picture this involves a set <img src="./ltximg/org-tex-553842f88e041ea2247955b5d3e4f0d3fade0907.svg" alt="\(X_{A}=X(A)\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> for each set <img src="./ltximg/org-tex-550c930ffedc4168896a70d86bbb4aa51088239f.svg" alt="\(A\)" style="height: 0.7680em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />. One gets indexed collections <img src="./ltximg/org-tex-28c8d8d5c54f6440b7896fafd1f9868f3ccf25e7.svg" alt="\((X_{A})_{A \in \mathbf{Sets}}\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> of sets <img src="./ltximg/org-tex-df46d901296ed7811eed834d437a17ca0b591360.svg" alt="\(X_{A}\)" style="height: 0.9150em; vertical-align: -0.1962em; display: inline-block" class="org-latex org-latex-inline" />.
</p>

<p>
These three type theories are thus distinguished by different forms of in-dexing of types: no indexing in simple type theory, indexing by term variables <img src="./ltximg/org-tex-30c42e67cb535f54813cee566a1e287b85aeb6aa.svg" alt="\(x\colon \sigma\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> in dependent type theory, and indexing by type variables <img src="./ltximg/org-tex-0e1d93003a291f688bd770028e4e5f06ed21242c.svg" alt="\(\alpha \colon \mathsf{Type}\)" style="height: 0.9695em; vertical-align: -0.2397em; display: inline-block" class="org-latex org-latex-inline" /> in polymorphic type theory. One can also combine dependent and polymorphic type theory, into more complicated type theories, for example, into what we call polymorphic dependent type theory (PDTT) or full higher order dependent type theory (FhoDTT).
</p>

<p>
What we have sketched in the beginning of this section is predicate logic over simple type theory. We shall call this simple predicate logic (SPL). An obvious extension is to consider predicate logic over dependent type theory, so that one can reason about terms in a dependent type theory. Another extension is logic over polymorphic type theory. This leads to dependent predicate logic(DPL) and to polymorphic predicate logic (PPL). If one sees a typed calculus as a (rudimentary) programming language, then these logics may be used as program logics to reason about programs written in simple, dependent, or polymorphic type theory. This describes logic as a “module” that one can plug on to a type theory.
</p>
</div>
</div>
<div id="outline-container-org51f8a74" class="outline-4">
<h4 id="org51f8a74"><span class="section-number-4">1.2.3.</span> part three: fibred category</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
This book focuses on such structural aspects of logic and type theory. The Language and techniques of category theory will be essential. For example, we talked about a logic <i>over</i> a type theory. Categorically this will correspond to one ("total") category, capturing the logic, being <i>fibred</i> over another ("base") category, capturing the type theory. Indeed, we shall make special use of tools from fibred category theory. This is a special part of category theory, stemming from the work of Grothendieck in algebraic geometry, in which (continuous) indexing of categories is studied. As we already mentioned, the various forms of type theoretic indexing distinguish varieties of type theory. And also, putting a logic on top of some type theory (in order to reason about it) will be described by putting a fibration on top of the categorical structure corresponding to the type theory. In this way we can put together complicated structures in a modular way.
</p>

<p>
Fibred category theory is ordinary category theory with respect to a base category. Also, one can say, it is ordinary category theory <i>over</i> a base category. Such a base category is like a universe. For example, several concepts in category theory are defined in terms of sets. One says that a category <img src="./ltximg/org-tex-ad26855c0f33214f710d85b3d6f61e7d61115d06.svg" alt="\(\C\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> has arbitrary products if for each <i>set</i> I and each <img src="./ltximg/org-tex-790e7dc1cdbf45441d1cb9799b6811b07b04005f.svg" alt="\(I\)" style="height: 0.7680em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />-indexed collection <img src="./ltximg/org-tex-dc2c47441be126772227a27a62ebc6393f7beeca.svg" alt="\((X_{i})_{i\in I}\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> of objects <img src="./ltximg/org-tex-54e371d2c4d2839e4f5ac2106d4215977f198843.svg" alt="\(X_{i}\in \C\)" style="height: 0.9205em; vertical-align: -0.1962em; display: inline-block" class="org-latex org-latex-inline" /> there is a product object <img src="./ltximg/org-tex-a0ea85c2c68b57d74c6ee24f7f76f01bab6228bb.svg" alt="\(\prod_{i\in I}X_{i}\in \C\)" style="height: 1.1793em; vertical-align: -0.3951em; display: inline-block" class="org-latex org-latex-inline" /> together with projection morphisms <img src="./ltximg/org-tex-96655a667c4f299f465275495d8b5d7629b769e2.svg" alt="\(\pi_{j} \colon (\prod _{i\in I}X_{i}) \to X_{j}\)" style="height: 1.1793em; vertical-align: -0.3951em; display: inline-block" class="org-latex org-latex-inline" />, which are suitably universal. In category theory one is not very happy with this privileged position of sets and so the question arises: is there a way to make sense of such products with respect to an object I of a ‘universe’ or ‘base category’ <img src="./ltximg/org-tex-3101be11f7d7a730403eab71940283d3adde67bb.svg" alt="\(\mathbb{B}\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, more general than the category <img src="./ltximg/org-tex-3cfb2aec1f48c460344c0618c96901c8e521e185.svg" alt="\(\mathbf{Sets}\)" style="height: 0.7708em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> of sets and functions? This kind of generality is needed to interpret logical products <img src="./ltximg/org-tex-a0a1d910218ea71c219772173dd410934f78dd79.svg" alt="\(\forall x \colon \sigma . \varphi\)" style="height: 0.9695em; vertical-align: -0.2397em; display: inline-block" class="org-latex org-latex-inline" /> or type theoretic products <img src="./ltximg/org-tex-b5df4f27e6595857e328577ec7f252a5b8182821.svg" alt="\(\Pi x\colon \sigma . \tau\)" style="height: 0.7680em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> when the domain of quantification <img src="./ltximg/org-tex-2ff9482801772a4a33f522c349a885df04455054.svg" alt="\(\sigma\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> is not interpreted as a set (but as some ordered set, or algebra, for example).
</p>

<p>
Another example is local smallness. A category <img src="./ltximg/org-tex-ad26855c0f33214f710d85b3d6f61e7d61115d06.svg" alt="\(\C\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> is locally small if for each pair of objects <img src="./ltximg/org-tex-b44cb6a7b00ce33545f93f17288380861f4b9ecd.svg" alt="\(X,  Y \in \C\)" style="height: 0.9640em; vertical-align: -0.2397em; display: inline-block" class="org-latex org-latex-inline" /> the morphisms <img src="./ltximg/org-tex-5f6633f88aa20331656d8316ffa7607b9ad25fad.svg" alt="\(X\to Y\)" style="height: 0.7680em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> in <img src="./ltximg/org-tex-ad26855c0f33214f710d85b3d6f61e7d61115d06.svg" alt="\(\C\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> form a <i>set</i> (as opposed to a proper class). That is, if one has homsets <img src="./ltximg/org-tex-a6c74a2b88e671a64ad0a786bed89bd427bf5ffd.svg" alt="\(\C(X,Y) \in \mathbf{Sets}\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> as objects in the category of sets. Again the question arises whether there is a way of saying that <img src="./ltximg/org-tex-ad26855c0f33214f710d85b3d6f61e7d61115d06.svg" alt="\(\C\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> is locally small with respect to an arbitrary universe or base category <img src="./ltximg/org-tex-3101be11f7d7a730403eab71940283d3adde67bb.svg" alt="\(\mathbb{B}\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> and not just with respect to <img src="./ltximg/org-tex-3cfb2aec1f48c460344c0618c96901c8e521e185.svg" alt="\(\mathbf{Sets}\)" style="height: 0.7708em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />.
</p>

<p>
Fibred category theory provides answers to such questions. It tells what it means for a category <img src="./ltximg/org-tex-98b2f0aee7aae528812a4d6a560f8daa2129b4a1.svg" alt="\(\mathbb{E}\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> to be “fibred over' a base category <img src="./ltximg/org-tex-3101be11f7d7a730403eab71940283d3adde67bb.svg" alt="\(\mathbb{B}\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />. In that case we
write <img src="./ltximg/org-tex-7dc1d35c0b5dd647b2527469595ec34e06a3e0c7.svg" alt="\(
\begin{gathered}
  \scriptstyle \mathbb{E}\\[-8pt]
  \scriptstyle\downarrow\\[-7pt]
  \scriptstyle \mathbb{B}
\end{gathered}\)" style="height: 2.7444em; vertical-align: -1.1272em; display: inline-block" class="org-latex org-latex-inline" />, where the arrow <img src="./ltximg/org-tex-e63c8f603de3cce6b249969e22a48f6540323774.svg" alt="\(\mathbb{E}\to \mathbb{B}\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> is a functor which has a certain property that makes it into a fibration. And in such a situation one can answer the above questions: one can define quantification with respect to objects <img src="./ltximg/org-tex-55d577a54b62d0f0605e852ff39fe284f58d784c.svg" alt="\(I \in \mathbb{E}\)" style="height: 0.8118em; vertical-align: -0.0875em; display: inline-block" class="org-latex org-latex-inline" /> and say when one has appropriate hom-objects <img src="./ltximg/org-tex-d5f6ecf6334b41b8c8a83071c535703002f34e88.svg" alt="\(\underline{\Hom}(X, Y)\in \mathbb B\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> for <img src="./ltximg/org-tex-31d6f437d081971b8497e9babb98562fd024cbd5.svg" alt="\(X, Y \in \mathbb{E}\)" style="height: 0.9640em; vertical-align: -0.2397em; display: inline-block" class="org-latex org-latex-inline" />. The ways of doing this will be explained in this book. And for a category <img src="./ltximg/org-tex-ad26855c0f33214f710d85b3d6f61e7d61115d06.svg" alt="\(\C\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> there is always a ‘family fibration’ <img src="./ltximg/org-tex-1cd0e1f9de7f8c0a42dc1c9affc61117a6c9138c.svg" alt="\(
\begin{gathered}
  \scriptstyle \mathrm{Fam}(\C)\\[-7pt]
  \scriptstyle \downarrow \\[-7pt]
  \scriptstyle \mathbf{Sets}
\end{gathered}\)" style="height: 2.8424em; vertical-align: -1.1762em; display: inline-block" class="org-latex org-latex-inline" /> of set-indexed families in <img src="./ltximg/org-tex-ad26855c0f33214f710d85b3d6f61e7d61115d06.svg" alt="\(\C\)" style="height: 0.7735em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />.
The fibred notions of quantification and local smallness, specialised to this family fibration, are the ordinary notions described above. Thus, in the family fibration we have our standard universe (or base category) of sets.
</p>
</div>
</div>
<div id="outline-container-org124d848" class="outline-4">
<h4 id="org124d848"><span class="section-number-4">1.2.4.</span> part four: categorical phenomena</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
There are many categorical notions arising naturally in logic and type theory (see the list below). And many arguments in category theory can be formulated conveniently using logic and type theory as “internal” language (sometimes called the “Mitchell-Benabou” language, in the context of topos theory). These fields however, have different origins: category theory arose in the work of Eilenberg and Mac Lane in the 1940s within mathematics, and was in the beginning chiefly used in algebra and topology. Later it found applications in almost all areas of mathematics (and computer science as well, more recently). Type theory is also from this century, but came up earlier in foundational work by Russell in logic (to avoid paradoxes). Recently, type theory has become important in various (notably functional) programming languages, and in computer mathematics: many type theories have been used during the last two decades as a basis for so-called(?) proof-assistants. These are special computer programs which assist in the verification of mathematical statements, expressed in the language of some (typed) logic. The use of types in these areas imposes certain restrictions on what can be expressed, but facilitates the detection of various errors. We think it is in a sense remarkable that two such fundamental fields (of category theory and of type theory)&#x2014;with their apparent differences and different origins&#x2014;are so closely related. This close relationship may be beneficial in the use and further development of both these fields.
</p>


<p>
We shall be especially interested in categorical phenomena arising within logic and type theory. Among these we mention the following.
</p>

<p>
(i) Every context of variable declarations (in type theory) or of premises(in logic) is an index. It is an index for a ‘fibre’ category which captures the logic or type theory that takes place within that context&#x2013;with the declared variables, or under the assumptions. The importance of this categorical role of contexts is our motivation for paying more than usual attention to contexts in our formulations of type theory and logic.
</p>

<p>
(ii) Appropriately typed sequences of terms give rise to morphisms be tween contexts. This is the canonical way to produce a category from types and terms. These context morphisms induce substitution functors between fibre categories. The structural operations of weakening (adding a dummy assumption) and contraction (replacing two assumptions of the same kind by a single one) appear as special cases of these substitution functors: weakening is substitution along a projection <img src="./ltximg/org-tex-a67ceb709103e22fca1594bf77653746fd25fc5f.svg" alt="\(\pi\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, and contraction is substitution along a diagonal <img src="./ltximg/org-tex-a2ddedd4a81820eeb979c973a8db46af30aa9559.svg" alt="\(\delta\)" style="height: 0.7789em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> . These <img src="./ltximg/org-tex-a67ceb709103e22fca1594bf77653746fd25fc5f.svg" alt="\(\pi\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> and <img src="./ltximg/org-tex-a2ddedd4a81820eeb979c973a8db46af30aa9559.svg" alt="\(\delta\)" style="height: 0.7789em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> may be Cartesian projections and diagonals in simple and polymorphic type theories, or ‘dependent’ projections and diagonals in dependent type theory.
</p>

<p>
(iii) The basic operations of logic and type theory can be described as adjoints in category theory. Such operations standardly come with an intro-duction and an elimination operation, which are each other's inverses (via the so-called (<img src="./ltximg/org-tex-9494f2ee6233dd93688ed309f2f39ac57663ffdd.svg" alt="\(\beta\)" style="height: 0.9695em; vertical-align: -0.2397em; display: inline-block" class="org-latex org-latex-inline" />)- and (<img src="./ltximg/org-tex-297bb25019b5527377b0e2b4391891aacd22fd46.svg" alt="\(\eta\)" style="height: 0.7109em; vertical-align: -0.2397em; display: inline-block" class="org-latex org-latex-inline" />)-conversions). Adjoint correspondences capture such situations. This may be familiar for the (simple) type theoretic constructors <img src="./ltximg/org-tex-0348bb19c0705a020d6a41ef08006194ee71e1c4.svg" alt="\(1\)" style="height: 0.7299em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, <img src="./ltximg/org-tex-4091c0eb70642e11ae64a067530cde7e652f4312.svg" alt="\(\times\)" style="height: 0.7517em; vertical-align: -0.1309em; display: inline-block" class="org-latex org-latex-inline" />, <img src="./ltximg/org-tex-25c55a5c0ef7fa2ed412d86467cf82e09b00fb20.svg" alt="\(0\)" style="height: 0.7299em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, <img src="./ltximg/org-tex-8f6e69ef262341d594f2c91bf3e494859d2c0fdc.svg" alt="\(+\)" style="height: 0.7517em; vertical-align: -0.1309em; display: inline-block" class="org-latex org-latex-inline" /> and <img src="./ltximg/org-tex-6a166f91f51dbeb5e1426e48f3fb1a183287aa2d.svg" alt="\(\to\)" style="height: 0.4579em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> (and for their propositional counterparts <img src="./ltximg/org-tex-3b7c4bd0caabe5b8ef402cd5185f904b24ceb6f6.svg" alt="\(\top\)" style="height: 0.7789em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, <img src="./ltximg/org-tex-d99cf72c61da4af0c239693e982aee707ec9d755.svg" alt="\(\land\)" style="height: 0.6428em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, <img src="./ltximg/org-tex-ae06e3a29318deac1580d9dda275578b3d080d33.svg" alt="\(\bot\)" style="height: 0.7789em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, <img src="./ltximg/org-tex-d9512b37ebdcd2d8ab70f02b38aa078710c661d4.svg" alt="\(\lor\)" style="height: 0.6428em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> and <img src="./ltximg/org-tex-60de881880bd9330789be101ece824501f1ff840.svg" alt="\(\supset\)" style="height: 0.6650em; vertical-align: -0.0875em; display: inline-block" class="org-latex org-latex-inline" />), since these are the operations of bicartesian closed categories (which can be described via standard adjunctions). But also existential <img src="./ltximg/org-tex-a2ada1f3dc1d11a5ee7f40d221c02c655599b27f.svg" alt="\(\exists x \colon\sigma .(-)\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> and universal <img src="./ltximg/org-tex-7df8d35b98d32657ef3baf3202e3dd6a4ed0abce.svg" alt="\(\forall x \colon \sigma.(-)\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> quantification in predicate logic over a type <img src="./ltximg/org-tex-2ff9482801772a4a33f522c349a885df04455054.svg" alt="\(\sigma\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, dependent sum <img src="./ltximg/org-tex-1c5a62250ee022f231cef93a246a1c851c3c3c3e.svg" alt="\(\Sigma x \colon \sigma . (-)\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> and product <img src="./ltximg/org-tex-bcbf3259455bf6472f803c714a43e763b77261da.svg" alt="\(\Pi \alpha\colon \sigma .(-)\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> in dependent type theory over a type <img src="./ltximg/org-tex-2ff9482801772a4a33f522c349a885df04455054.svg" alt="\(\sigma\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, and polymorphic sum <img src="./ltximg/org-tex-4c70c53e47b354fa3f9c9eed5a28b6058aae946c.svg" alt="\(\Sigma \alpha \colon \mathsf{Type}.(-)\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> and product <img src="./ltximg/org-tex-23b0eb85191ed23b1dd56e33f81438f8144e0431.svg" alt="\(\Pi \alpha \colon \mathsf{Type}.(-)\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" />in polymorphic type theory over the universe Type of types, are characterised as left and right adjoints, namely to the weakening functor which adds an extra dummy assumption <img src="./ltximg/org-tex-f194c5a55599b7b96c3000ae920bd86d613cc739.svg" alt="\(x\colon\sigma\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, or <img src="./ltximg/org-tex-0e1d93003a291f688bd770028e4e5f06ed21242c.svg" alt="\(\alpha \colon \mathsf{Type}\)" style="height: 0.9695em; vertical-align: -0.2397em; display: inline-block" class="org-latex org-latex-inline" />. Moreover, equality <img src="./ltximg/org-tex-45ff8db6593d066172a89b37dd12903171fea89e.svg" alt="\(=_{\alpha}\)" style="height: 0.6049em; vertical-align: -0.1962em; display: inline-block" class="org-latex org-latex-inline" /> on a type <img src="./ltximg/org-tex-2ff9482801772a4a33f522c349a885df04455054.svg" alt="\(\sigma\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> is characterised as left adjoint to the contraction functor which replaces two variables <img src="./ltximg/org-tex-c4ea239ff8870733f0b569e20365d31a666e94ff.svg" alt="\(x, y \colon \sigma\)" style="height: 0.7109em; vertical-align: -0.2397em; display: inline-block" class="org-latex org-latex-inline" /> by a single one (by substituting <img src="./ltximg/org-tex-9ea8917703565f13d2a7c311ca1ce811c9f30b43.svg" alt="\(x\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> for <img src="./ltximg/org-tex-6938085fec760d90498317b055ac0f72b03ef727.svg" alt="\(y\)" style="height: 0.7109em; vertical-align: -0.2397em; display: inline-block" class="org-latex org-latex-inline" />). By ‘being characterised’ we mean that the standard logical and type-theoretical rules for these operations are (equivalent to) the rules that come out by describing these operations as appropriate adjoints.
</p>

<p>
The most important adjunctions are:
</p>

<p>
<img src="./ltximg/org-tex-429f63bb5d4cbabd09681614e2a5ebe523a65155.svg" alt="\[
\begin{aligned}
\text{existential }  \exists , \text{ sum } \Sigma
  &amp;amp; \dashv \text{ weakening}\\
\text{weakening}
  &amp;amp; \dashv \text{ contraction}\\
\text{equality}
  &amp;amp; \dashv \text{ comprehension}\\
\text{(but also: equality}
  &amp;amp; \dashv \text{ comprehension, via a different functor)}\\
\text{quotients}
  &amp;amp; \dashv \text{ equality}
\end{aligned}\]" style="height: 7.2524em; display: block" class="org-latex org-latex-block" />
</p>

<p>
The first four of these adjoints were recognised by Lawvere (and the last two are identified in this book). Lawvere first described the quantifiers <img src="./ltximg/org-tex-d30d4d76de65739b15cee3295bb420c1f0d13d24.svg" alt="\(\exists\)" style="height: 0.7789em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, <img src="./ltximg/org-tex-f49a42152dcef74443806f47153d90f97320261d.svg" alt="\(\forall\)" style="height: 0.7789em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> as left and right adjoints to arbitrary substitution functors. The above picture with separate adjoints to weakening and to contraction functors is a refinement, since, as we mentioned in (ii), weakening and contraction functors are special cases of substitution functors. (These operations of weakening and contraction can be suitably organised as a certain comonad; we shall define quantification and equality abstractly with respect to such comonads.)
</p>

<p>
(iv) As we mentioned above, the characteristic aspect of dependent type theory is that types may depend on types, in the sense that term variables inhabiting types may occur in other types. And the characteristic aspect of polymorphic type theory is that type variables may occur in types. Later we shall express this as: types may depend on kinds. These dependencies amount to certain forms of indexing. They are described categorically by fibred (or indexed) categories. Thus, if one knows the dependencies in a type theory, then one knows its underlying categorical structure. The additional type theoretic structure may be described via certain adjunctions, as in the previous point.
</p>

<p>
(v) Models of logics and type theories are (structure preserving) functors. From a specific system in logic or type theory one can syntactically build a so-called ‘classifying’ (fibred) category, using a term model&#x2014;or generalised Lindenbaum-Tarski&#x2014;construction. A model of this system is then a (fibred) functor with this classifying (fibred) category as domain, preserving appropriate structure. We shall make systematic use of this <i>functorial semantics</i>. It was introduced by Lawvere for single-typed simple type theories. And it ex-tends to other logics and type theories, and thus gives a systematic description of models of (often complicated) logics and type theories.
</p>

<p>
(vi) If <img src="./ltximg/org-tex-3a0adedfdde2d46afd558f89a69acfbb3e1dab73.svg" alt="\(\sigma = \sigma (\alpha)\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> is a type (in polymorphic type theory) in which a free type variable <img src="./ltximg/org-tex-3bce569d60cc18a26dcd40d71fce5082e782af8a.svg" alt="\(\alpha\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> occurs,then,under reasonable assumptions about type formation, the operation <img src="./ltximg/org-tex-8e19c58b19d0daa734963e89c2b636a6ceb1d058.svg" alt="\(\tau \mapsto \sigma [\tau / \alpha]\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> of substituting a type <img src="./ltximg/org-tex-c187eb577344f106e8570dfaae4518ee41d05ecd.svg" alt="\(\tau\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> for <img src="./ltximg/org-tex-3bce569d60cc18a26dcd40d71fce5082e782af8a.svg" alt="\(\alpha\)" style="height: 0.5203em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />, is functorial. This functoriality is instrumental in describing the rules of (co-)inductively defined data types in terms of (co-)algebras of this functor. And the reasoning principles (or logic) associated with such data types can also be captured in terms of (co-)algebras (but for a different functor, obtained by lifting the original functor to the logical world of predicates and relations).
</p>

<p>
(vii) A logical framework is a type theory <img src="./ltximg/org-tex-92278922d295f3cbdc5bbe41920276b4b8cb96b5.svg" alt="\(\mathcal T\)" style="height: 0.7680em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> which is expressive enough so that one can formulate other systems <img src="./ltximg/org-tex-8ca48931e0883779300dbec7a5d57ab05ab458e2.svg" alt="\(S\)" style="height: 0.7680em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> of logic or of type theory inside <img src="./ltximg/org-tex-92278922d295f3cbdc5bbe41920276b4b8cb96b5.svg" alt="\(\mathcal T\)" style="height: 0.7680em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />. Categorically one may then describe (the term model of) <img src="./ltximg/org-tex-8ca48931e0883779300dbec7a5d57ab05ab458e2.svg" alt="\(S\)" style="height: 0.7680em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> as an internal category in (the term model of) <img src="./ltximg/org-tex-a48fff8e986de6ea0f8e4ca82906ec9083d5d002.svg" alt="\(\cal T\)" style="height: 0.7680em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />. We briefy discuss dependent type theory as a logical framework in Section 10.2, but we refer to [87] for this connection with internal categories.
</p>
</div>
</div>
<div id="outline-container-orgd9146e7" class="outline-4">
<h4 id="orgd9146e7"><span class="section-number-4">1.2.5.</span> part five: categorical structures</h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
This is not a book properly on logic or on type theory. Many logical and type theoretical calculi are described and some illustrations of their use are given, but there is nothing about specific proof-theoretic properties like cut-elimination, Church-Rosser or strong normalisation. Therefore, see [14]. The emphasis here lies on categorical semantics. This is understood as follows. Category theory provides means to say what a model of, say predicate logic, should look like. It gives a specification, or a hollow structure, which captures the essentials. A proper model is something else, namely an instance of such a structure. We shall describe both these hollow structures, and some instances of these. (But we do not investigate the local structure or theories of the example models, like for example in [197] or in [13, Chapter 19].)
</p>

<p>
So what, then, is the advantage of knowing what the categorical structures are, corresponding to certain logics and type theories?
</p>

<p>
Firstly, it enables us to easily and quickly recognise that certain mathematical structures are models of some logical or type theoretical calculus, without having to write out an interpretation in detail. The latter can be given for the ‘hollow categorical structure’, and need not be repeated for the particular instances. One only has to check that the particular structure is an instance of the general categorical structure. For example, knowing that a particular category (of domains, say) is Cartesian closed yields the information that we can interpret simple type theory.
</p>

<p>
Secondly, once this is realised, we can turn things around, and start using our calculus (suitably incorporating the constants in a signature) to reason directly and conveniently about a (concrete or abstract categorical) model. This is the logician's view of the mathematician's use of language: when reasoning about a particular mathematical structure (say a group <img src="./ltximg/org-tex-f98648aebe245a002f165c7d4e1971e846113d12.svg" alt="\(G\)" style="height: 0.7680em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />), one formally adds the elements <img src="./ltximg/org-tex-764534068368771b7b1fee1bb78c17df516dabbd.svg" alt="\(a \in G\)" style="height: 0.8063em; vertical-align: -0.0875em; display: inline-block" class="org-latex org-latex-inline" /> as constants <img src="./ltximg/org-tex-8a130e1330d783bf7978fd2a05413cc40f201e9c.svg" alt="\(\underline{a}\)" style="height: 0.7163em; vertical-align: -0.2452em; display: inline-block" class="org-latex org-latex-inline" /> to the language, and one uses the resulting “internal” language to reason directly about <img src="./ltximg/org-tex-f98648aebe245a002f165c7d4e1971e846113d12.svg" alt="\(G\)" style="height: 0.7680em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" />. The same approach applies to more complex mathematical structures, like a fibred category of domains: one then needs a suitable type theoretic language to reason about such a complex (indexed) structure.
</p>

<p>
The third advantage is what a clear (categorical) semantics provides a certain syntactic hygiene, and deepens the understanding of the various logical and type theoretical systems. For example, the principle that a (possibly new) operation in logic or type theory should correspond to an adjoint gives certain canonical introduction, elimination and conversion rules for the constructor. Fourthly, models can be used to obtain new results about one's logical or type theoretical system. Consistency, conservativity and independence results are often obtained in this manner. Finally, and maybe most importantly, models provide meaning to one's logical or type theoretical language, resulting in a better understanding of the syntax.
</p>

<p>
There are so many systems of logic and type theory because there are certain"production rules" which generate new systems from given ones.
</p>

<p>
(i) There are three basic type theories: simple type theory (STT), depen-dent type theory (DTT) and polymorphic type theory (PTT).
</p>

<p>
(ii) Given a certain type theory, one can construct a logic over this type theory with predicates <img src="./ltximg/org-tex-63771252086adf5b4dfcfb6429726a59cc1cd94c.svg" alt="\(\varphi (\vec x) \colon \Prop\)" style="height: 1.0784em; vertical-align: -0.2942em; display: inline-block" class="org-latex org-latex-inline" /> containing free variables <img src="./ltximg/org-tex-99f51c939b6a6a37044f6359f0c4374951fd225c.svg" alt="\(\vec x\)" style="height: 0.7985em; vertical-align: -0.0492em; display: inline-block" class="org-latex org-latex-inline" /> inhabiting types. This allows us to reason about (terms in) the given type theory.
</p>

<p>
(ili) Given a logic (over some type theory), one can construct a new type theory (extending the given one) by a propositions-as-types upgrade: one considers the propositions <img src="./ltximg/org-tex-dc9a9612630dcdf439a29856e035e26e243b1bf5.svg" alt="\(\varphi\)" style="height: 0.7109em; vertical-align: -0.2397em; display: inline-block" class="org-latex org-latex-inline" /> in the logic as types in the new type theory, and derivations in the logic as terms in the new type theory.
</p>

<p>
This modularity is reflected categorically in the following three points.
</p>

<p>
(i) There are three basic categorical structures: for STT (Cartesian closed categories), for DTT (what we call closed comprehension categories) and for PTT (certain fibred Cartesian closed categories).
</p>

<p>
(ii) Putting a logic on a type theory corresponds to putting a preorder fbration on top of the structure describing the type theory. For logic one uses preorder structures, since in logic one is interested in provability and not in explicit proofs (or proof-terms, as in type theory), which are described as non-trivial morphisms.
</p>

<p>
(ii) Under a propositions-as-types upgrade one replaces a preorder fibra-tion by an ordinary fibration (with proper fibre categories), thus making room for proof-terms as proper morphisms.
</p>

<p>
(Both second points are not as unproblematic as they may seem, because one may have complicated type theories, say with two syntactic universes of types and of kinds, in which there are many ways of putting a logic on top of such a type theory: one may wish to reason about types, or about kinds, or about both in the same logic. Categorically, there are similarly different ways in which a preorder fibration can be imposed.)
</p>

<p>
By the very nature of its contents, this book is rather descriptive. It contains few theorems with deep mathematical content. The influence of computer science may be felt here, in which much emphasis is put on the description of various languages and formalisms.
</p>
</div>
</div>
<div id="outline-container-orga6a181b" class="outline-4">
<h4 id="orga6a181b"><span class="section-number-4">1.2.6.</span> part six: what this book is not</h4>
<div class="outline-text-4" id="text-1-2-6">
<p>
Also, it is important to stress that this is not a book properly on fibred category theory. And it is not intended as such. It does contain the basic concepts and results from fibred category theory, but only as far as they are directly useful in logic or type theory (and not in topology, for example). Some of these basic results have not been published previously, but have been folklore for some time already. They have been discovered and rediscovered by various people, and the precise fow of ideas is hard to track in detail. What we present in this book is not a detailed historical account, and we therefore apologise in advance for any misrepresentation of history.
</p>

<p>
We sketch what we see as the main lines. In the development of fibred category and categorical logic one can distinguish an initial French period starting in the 1960s with Grothendieck's definition of a fibration (i.e. a fibred category), published in [107]. It was introduced in order to study descent. The ensuing theory was further developed by Grothendieck and (among others) Giraud [100] and Benabou. The latter's work is more logical and foundational in spirit than Grothendieck's (involving for example suitable fibred notions of local smallness and definability), and is thus closest to the current work. Many of the basic notions and results stem from this period.
</p>

<p>
In the late 1960s Lawvere first applied indexed categories in the study of logic. Especially, he described quantification and equality in terms of adjoints to substitution functors,and showed that also comprehension involves an adjunction. This may be seen as the start of categorical logic (explicitly, in his influential “Perugia Lecture Notes” and also in [192, 193]). At about the same time, the notion of elementary topos was formulated, by Lawvere and Tierney. This resulted in renewed attention for indexed (and internal) categories, to study phenomena over (and inside) toposes. See for example [173, 169] and the references there.
</p>

<p>
Then, in the 1980s there is the start of a type theoretic boom, in which indexed and fibred categories are used in the semantics of polymorphic and dependent type theories, see the basic papers 306, 307, 148] and the series of PhD theses [45,330,75,185,318,252,260,7,154,89,217,86,60,289, 125, 4, 198, 133]. This book collects much material from this third phase. Explicitly, the connection between simple type theory and Cartesian closed categories was first established by Lawvere and Lambek. Later, dependent type theory was related to locally Cartesian closed categories by Seely, and to the more general “display map categories” by Taylor. The relation between polymorphic type theory and certain fibred (or indexed, or internal) Cartesian closed categories is due to Seely, Lamarche and Moggi. Finally, more compli-cated systems combining polymorphic and dependent systems (like the calcu-lus of constructions) were described categorically by Hyland, Pitts, Streicher, Ehrhard, Curien, Pavlovic, Jacobs and Dybjer. This led to the (surprising) discovery of complete internal categories by Moggi and Hyland (and to the subsequent development of ‘synthetic’ domain theory in abstract universes).
</p>

<p>
Interestingly, fibred categories are becoming more and more important in various other areas of (theoretical) computer science, precisely because the aspects of indexing and substitution (also called renaming, or relabelling) are so fundamental.Among these areas we mention(without pretension to be in any sense complete): database theory [295, 151, 9], rewriting [12], automata theory [175, 10], abstract environments [279], data flow networks [310], constraint programming [219], concurrency theory [345, 131], program analysis [230, 25], abstract domain theory [146] and specification [152, 327, 48, 159].
</p>

<p>
Many topics in the field of categorical logic and type theory are not discussed in this book. Sometimes because the available material is too recent (and un-settled), sometimes because the topic deviates too much from the main line, but mostly simply because of lack of space. Among these topics we mention(with a few references): inductively and co-inductively defined types in depen-dent type theory [70, 71], categorical combinators [63, 290, 116], categorical normalisation proofs [147, 238, 5], fixed points [16], rewriting and 2-categorical] structure [308, 278], modal logic [93], μ-calculi [313], synthetic domain theory [144, 331, 264], a fibred Giraud theorem [229], a fibred adjoint functor theorem [47, 246], descent theory [168] (especially with its links to Beth de-finability [208]], fbrations in bi-categories [315, 317], 2-fbrations [127], and the theory of stacks [100].
</p>

<p>
The choice has been made to present details of interpretation functions for simple type theory in full detail in Chapter 2, together with the equivalent functorial interpretation. In later chapters interpretations will occur mostly in the more convenient functorial form. For detailed information about interpre-tation functions in polymorphic and (higher order) dependent type theories we refer to [319, 61]. As we proceed we will be increasingly blurring the distinction between certain type theories and certain fibred categories, thus decreasing the need for explicit interpretations</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2024-10-19 Sat 16:08</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
