<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-11-21 Thu 15:12 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TODO(s)</title>
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  pre.src-C\+\+:before { content: 'C++'; }
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">TODO(s)</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org264c330">1. <span class="todo TODO">TODO</span> <code>[0/2]</code></a></li>
<li><a href="#orgab5bae2">2. reading list</a></li>
<li><a href="#org43e7f97">3. test&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></a></li>
<li><a href="#org095456f">4. CallCC: a classic operator that defies intuition — Christine's World Wide Web Site&#xa0;&#xa0;&#xa0;<span class="tag"><span class="website">website</span></span></a>
<ul>
<li><a href="#orga92023d">4.1. Article</a>
<ul>
<li><a href="#orgc6a2799">4.1.1. CallCC: a classic operator that defies intuition</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org264c330" class="outline-2">
<h2 id="org264c330"><span class="section-number-2">1.</span> <span class="todo TODO">TODO</span> <code>[0/2]</code></h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li class="off"><code>[&#xa0;]</code> 给出问题建模</li>
<li class="off"><code>[&#xa0;]</code> 先是回答什么是问题建模？</li>
</ul>

<p>
我们经常能在 introduction 里面看到 "the main contribution of this thesis" 被提及。可以说 contribution 这个部分可以分为三个部分：
</p>

<ol class="org-ol">
<li>问题的提出、具体的场景、尝试解决的问题（痛点）</li>
<li>使用的方法</li>
<li>评估方法和结果</li>
</ol>

<p>
也就是说，在这里我们应当给出第一个部分
</p>
</div>
</div>
<div id="outline-container-orgab5bae2" class="outline-2">
<h2 id="orgab5bae2"><span class="section-number-2">2.</span> reading list</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>call/cc 和 LEM（排中律）之间的关系</li>
<li><a href="https://pithlessly.github.io/callcc.html">https://pithlessly.github.io/callcc.html</a></li>
<li>中文 lean 文档</li>
<li><a href="https://www.leanprover.cn/">https://www.leanprover.cn/</a></li>
</ul>
</div>
</div>
<div id="outline-container-org43e7f97" class="outline-2">
<h2 id="org43e7f97"><span class="section-number-2">3.</span> test&#xa0;&#xa0;&#xa0;<span class="tag"><span class="ARCHIVE">ARCHIVE</span></span></h2>
</div>
<div id="outline-container-org095456f" class="outline-2">
<h2 id="org095456f"><span class="section-number-2">4.</span> <a href="https://pithlessly.github.io/callcc.html">CallCC: a classic operator that defies intuition — Christine's World Wide Web Site</a>&#xa0;&#xa0;&#xa0;<span class="tag"><span class="website">website</span></span></h2>
<div class="outline-text-2" id="text-4">
<p>
<span class="timestamp-wrapper"><span class="timestamp">[2024-11-21 Thu 15:08]</span></span>
</p>
</div>
<div id="outline-container-orga92023d" class="outline-3">
<h3 id="orga92023d"><span class="section-number-3">4.1.</span> Article</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-orgc6a2799" class="outline-4">
<h4 id="orgc6a2799"><span class="section-number-4">4.1.1.</span> CallCC: a classic operator that defies intuition</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
<i>Epistemic status: essentially a personal note. Might have any number of misconceptions.</i>
</p>

<p>
I've recently been thinking about the “call with current continuation” operator, a rather magical primitive operation which is included in some functional programming languages, most notably Scheme. <code>call-with-current-continuation</code> can be described as reifying the return operator: it provides a function with an additional argument, which, when called, will cause the function to immediately return. For example, these programs are equivalent:
</p>

<pre class="example" id="org8ab9d9b">
 (call-with-current-continuation
  (lambda (return)
    (+ 5 5)))

(call-with-current-continuation
  (lambda (return)
    (return (+ 5 5))
    (whatever))) ; this statement will never be evaluated
</pre>

<p>
<code>return</code> here is called a <i>continuation</i> and more conventionally named <code>k</code>. Like <code>return</code> statements in imperative languages, execution of the function body stops once it is called. What I noticed is that this breaks referential transparency, which (broadly) means that the program's results shouldn't depend on the evaluation strategy. Consider this program:
</p>

<pre class="example" id="orgd43f22e">
(call-with-current-continuation
 (lambda (k)
   (define var (list (k 1)
                     (k 2)))
   3))
</pre>

<p>
What does this return? The answer depends on the order of evaluation:
</p>

<ul class="org-ul">
<li>If the first call to <code>k</code> is evaluated first, the function exits with return value 1.</li>
<li>If the second call to <code>k</code> is evaluated first, the function exits with return value 2.</li>
<li>If the compiler notices that <code>var</code> is never used, and decides not to evaluate it at all, then the function returns normally with return value 3. This transformation is generally not permissible in languages with side effects, but languages like Haskell do it.</li>
</ul>

<p>
(The actual answer is that it could return either 1 or 2, but not 3. Scheme requires side effects to be handled but does not specify what order arguments can be evaluated in.)
</p>

<p>
So having <code>call-with-current-continuation</code> (also known as <code>call/cc</code>) in the language breaks referential transparency. As a corollary, it cannot be implemented in a referentially transparent language. This is why I called it a <i>primitive operator</i> rather than simply an ordinary function. The presence or absence of <code>call/cc</code> makes a meaningful difference to a language's semantics which is worth investigation.
</p>

<p>
Another thing I was thinking about at the time was an excerpt from an article I read in middle school. I don't remember the article's content, and most of it went over my head, but a comment that was somewhat independent from the article's main point stuck with me. To paraphrase:
</p>

<blockquote>
<p>
Implementing the law of the excluded middle requires writing a term <code>lem :: Either a (a -&gt; Void)</code>. This can be implemented by first returning <code>Right</code> with an opaque function <code>a -&gt; Void</code>. There is nothing the user could do with this function except pass in a value of type <code>a</code> to obtain a contradiction. At this point, the runtime has a value of type <code>a</code>, and can rewind the computation and return <code>Left a</code> with the provided value.
</p>

<p>
<i><b>Edit (2022-09-29):</b> it may have been <a href="https://queuea9.wordpress.com/2018/10/17/why-i-no-longer-believe-in-computational-classical-type-theory">this article</a>, although that isn't consistent with the timing.</i>
</p>
</blockquote>

<p>
This idea of “rewinding the computation” seems an awful lot like <code>call/cc</code>, doesn't it? In fact, we can formalize this intuition by “proving” (defining) <code>lem</code> and <code>call/cc</code> in terms of each other in Haskell.
</p>

<pre class="example" id="org205ecac">
 data Void

lem :: Either a (a -&gt; Void)
lem = callCC (\k -&gt; Right (\a -&gt; k (Left a)))

callCC :: ((a -&gt; Void) -&gt; a) -&gt; a
callCC f = case lem of
  Left (a :: a) -&gt; a
  Right (na :: a -&gt; Void) -&gt; f na
</pre>

<p>
Another axiom equivalent to the law of the excluded middle is double negation elimination: the conversion from a proof that something <i>cannot be false</i> to a proof that it <i>is true</i>. Double negation elimination and <code>call/cc</code> can be implemented in terms of each other.
</p>

<pre class="example" id="orgbd87c47">
 dne :: ((a -&gt; Void) -&gt; Void) -&gt; a
dne na = callCC (\k -&gt; absurd (na k))
  where absurd (v :: Void) = case v of {} -- from falsehood, anything follows

callCC :: ((a -&gt; Void) -&gt; a) -&gt; a
callCC f = dne (\not_a -&gt; not_a (f not_a))

-- I'm not going to implement `lem` and and `dne` in terms of each other,
-- since it's not quite relevant to this topic and can be derived from the
-- implementations given here.
</pre>

<p>
This, to me, indicates a connection between having a <code>call/cc</code>-like operation and <i>proof-relevance</i>. Double negation elimination, the LEM, and Pierce's law (which is the analogue of <code>call/cc</code> in classical logic) &#x2014; these all seem intuitively correct in classical logic, and the reason is that we're okay with, for example, proving a disjunction (“either A or B is true”) without having an algorithm that determines which side of the disjunction it is.
</p>

<p>
The reason these operations seem “weird” when interpreted as programs is that we do care about proofs &#x2014; we expect to be able to “pattern match” and determine which case of a sum type holds. Introducing <code>call-cc</code> as a primitive operator weakens this ability, because we lose agnosticism of evaluation order: we know <code>call/cc</code> returns a value of type <code>a</code>, but as the initial examples demonstrated, the types alone don't tell us enough to know which one exactly.
</p>

<p>
I suspect that the computational structure of negation is related to the distinction between propositions and types in many dependently typed proof assistants: propositions are a subset of types whose proofs cannot be inspected or pattern matched, enabling the language to introduce classical axioms as propositions without breaking referential transparency.
</p>

<hr />

<p>
<a href="https://soupault.app/">[[./buttons/powered-by-soupault.png</a>]] <img src="./buttons/bookmark_this_page.gif" alt="bookmark_this_page.gif" /> <img src="./buttons/any-browser.gif" alt="any-browser.gif" /> <img src="./buttons/trans-flag.png" alt="trans-flag.png" /> <img src="./buttons/ace-flag.png" alt="ace-flag.png" /> <img src="./buttons/firefox.gif" alt="firefox.gif" /> <a href="https://roseiverse.com">[[https://roseiverse.com/buttons/roseiverse.png</a>]]
</p>

<p>
<a href="https://tailscale.com/">[[./buttons/tailscale.png</a>]] <img src="./buttons/fediverse.gif" alt="fediverse.gif" /> <a href="https://bitwarden.com/">[[./buttons/bitwarden.gif</a>]] <a href="https://haskell.org">[[./buttons/haskell.png</a>]] <img src="./buttons/latex.gif" alt="latex.gif" /> <img src="./buttons/linux.gif" alt="linux.gif" /> <img src="./buttons/sun.gif" alt="sun.gif" /> <a href="https://archive.org/">[[./buttons/internetarchive.gif</a>]] <img src="./buttons/antinft.gif" alt="antinft.gif" /> <img src="./buttons/iso8601.png" alt="iso8601.png" />
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2024-11-21 Thu 15:12</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
