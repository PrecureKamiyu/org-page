#+title:TODO(s)
#+startup: overview

* TODO [0/2]

  - [ ] 给出问题建模
  - [ ] 先是回答什么是问题建模？

我们经常能在 introduction 里面看到 "the main contribution of this thesis" 被提及。可以说 contribution 这个部分可以分为三个部分：

  1. 问题的提出、具体的场景、尝试解决的问题（痛点）
  2. 使用的方法
  3. 评估方法和结果

也就是说，在这里我们应当给出第一个部分

* reading list

  + call/cc 和 LEM（排中律）之间的关系
  + https://pithlessly.github.io/callcc.html
  + 中文 lean 文档
  + https://www.leanprover.cn/

* test                                                              :ARCHIVE:

** 第一步，给出问题建模

其实我已经给出来了，我觉得可以将文件上的直接进行一个复制粘贴。

** 第二步，给出我的方法的解决了的痛点

其实这点也应该是写出来了的，只不过是原创性不是很高罢了。

** 闲话，我觉得主要还是 PPT 战神

真的是……

** 第三步，给出模拟器？
* [[https://pithlessly.github.io/callcc.html][CallCC: a classic operator that defies intuition — Christine's World Wide Web Site]] :website:

[2024-11-21 Thu 15:08]

** Article

*** CallCC: a classic operator that defies intuition

/Epistemic status: essentially a personal note. Might have any number of misconceptions./

I've recently been thinking about the “call with current continuation” operator, a rather magical primitive operation which is included in some functional programming languages, most notably Scheme.

=call-with-current-continuation= can be described as reifying the return operator: it provides a function with an additional argument, which, when called, will cause the function to immediately return. For example, these programs are equivalent:

#+BEGIN_EXAMPLE
    (call-with-current-continuation
      (lambda (return)
        (+ 5 5)))

    (call-with-current-continuation
      (lambda (return)
        (return (+ 5 5))
        (whatever))) ; this statement will never be evaluated
#+END_EXAMPLE

=return= here is called a /continuation/ and more conventionally named =k=. Like =return= statements in imperative languages, execution of the function body stops once it is called. What I noticed is that this breaks referential transparency, which (broadly) means that the program's results shouldn't depend on the evaluation strategy. Consider this program:

#+BEGIN_EXAMPLE
    (call-with-current-continuation
      (lambda (k)
        (define var (list (k 1)
                          (k 2)))
        3))
#+END_EXAMPLE

What does this return? The answer depends on the order of evaluation:

- If the first call to =k= is evaluated first, the function exits with return value 1.
- If the second call to =k= is evaluated first, the function exits with return value 2.
- If the compiler notices that =var= is never used, and decides not to evaluate it at all, then the function returns normally with return value 3. This transformation is generally not permissible in languages with side effects, but languages like Haskell do it.

(The actual answer is that it could return either 1 or 2, but not 3. Scheme requires side effects to be handled but does not specify what order arguments can be evaluated in.)

So having =call-with-current-continuation= (also known as =call/cc=) in the language breaks referential transparency. As a corollary, it cannot be implemented in a referentially transparent language. This is why I called it a /primitive operator/ rather than simply an ordinary function. The presence or absence of =call/cc= makes a meaningful difference to a language's semantics which is worth investigation.

Another thing I was thinking about at the time was an excerpt from an article I read in middle school. I don't remember the article's content, and most of it went over my head, but a comment that was somewhat independent from the article's main point stuck with me. To paraphrase:

#+BEGIN_QUOTE
  Implementing the law of the excluded middle requires writing a term =lem :: Either a (a -> Void)=. This can be implemented by first returning =Right= with an opaque function =a -> Void=. There is nothing the user could do with this function except pass in a value of type =a= to obtain a contradiction. At this point, the runtime has a value of type =a=, and can rewind the computation and return =Left a= with the provided value.

  /*Edit (2022-09-29):* it may have been [[https://queuea9.wordpress.com/2018/10/17/why-i-no-longer-believe-in-computational-classical-type-theory][this article]], although that isn't consistent with the timing./
#+END_QUOTE

This idea of “rewinding the computation” seems an awful lot like =call/cc=, doesn't it? In fact, we can formalize this intuition by “proving” (defining) =lem= and =call/cc= in terms of *each other* in Haskell.

#+BEGIN_EXAMPLE
    data Void

    lem :: Either a (a -> Void)
    lem = callCC (\k -> Right (\a -> k (Left a)))

    callCC :: ((a -> Void) -> a) -> a
    callCC f = case lem of
      Left (a :: a) -> a
      Right (na :: a -> Void) -> f na
#+END_EXAMPLE
Note: the example above is extremely odd.

Another axiom equivalent to the law of the excluded middle is double negation elimination: the conversion from a proof that something /cannot be false/ to a proof that it /is true/. Double negation elimination and =call/cc= can be implemented in terms of each other.

#+BEGIN_EXAMPLE
    dne :: ((a -> Void) -> Void) -> a
    dne na = callCC (\k -> absurd (na k))
      where absurd (v :: Void) = case v of {} -- from falsehood, anything follows

    callCC :: ((a -> Void) -> a) -> a
    callCC f = dne (\not_a -> not_a (f not_a))

    -- I'm not going to implement `lem` and and `dne` in terms of each other,
    -- since it's not quite relevant to this topic and can be derived from the
    -- implementations given here.
#+END_EXAMPLE

This, to me, indicates a connection between having a =call/cc=-like operation and /proof-relevance/. Double negation elimination, the LEM, and Pierce's law (which is the analogue of =call/cc= in classical logic) --- these all seem intuitively correct in classical logic, and the reason is that we're okay with, for example, proving a disjunction (“either A or B is true”) without having an algorithm that determines which side of the disjunction it is.

The reason these operations seem “weird” when interpreted as programs is that we do care about proofs --- we expect to be able to “pattern match” and determine which case of a sum type holds. Introducing =call-cc= as a primitive operator weakens this ability, because we lose agnosticism of evaluation order: we know =call/cc= returns a value of type =a=, but as the initial examples demonstrated, the types alone don't tell us enough to know which one exactly.

I suspect that the computational structure of negation is related to the distinction between propositions and types in many dependently typed proof assistants: propositions are a subset of types whose proofs cannot be inspected or pattern matched, enabling the language to introduce classical axioms as propositions without breaking referential transparency.

* COMMENT [[https://www.leanprover.cn/][Lean 中文文档 - Lean Prover 中文文档]]                              :website:

[2024-11-21 Thu 14:53]

** Article

*** Lean 中文文档 [[#lean][¶]]


[[mailto:leanprover@outllook.com][[[https://img.shields.io/badge/Email-联系我们-informational?style=flat&logo=microsoft-outlook&logoColor=white]]]] [[https://t.me/Lean_zh_CN][[[https://img.shields.io/badge/Telegram-加入讨论-blue?style=flat&logo=telegram&logoColor=white]]]] [[http://qm.qq.com/cgi-bin/qm/qr?_wv=1027&k=tC0R88AwoljjpvA2fGAvkucJCOeJnLDR&authKey=AHE8WSVpMeNAoc4Ax8%2BkiM%2FrBkAcpFfcuc7V746wcdIWXYloyGWcn2IkBhpVsumI&noverify=0&group_code=897971266][[[https://img.shields.io/badge/QQ-加入群聊-blue.svg?logo=tencent-qq&style=flat]]]] [[https://www.leanprover.cn][[[https://img.shields.io/badge/Website-访问主页-blue.svg?style=flat]]]]

**** Lean 简介 [[#lean_1][¶]]


Lean 是一个交互式定理证明器（Interactive Theorem Prover, ITP），也是一门通用函数式编程语言。微软研究院在 2013 年推出这一计算机定理证明器，数学家可以把数学定理转换成代码，再输入到 Lean 中，让程序来验证定理是否正确。当被视为编程语言时，Lean 是一种具有 *依赖类型* 的 *严格* 的 *纯函数式* 语言(strict pure functional with dependent types)。

在形式化方面，Lean 提供了一套严格的逻辑和数学框架，使得用户可以进行精确的推理和证明。这个特性使得 Lean 在数学和计算机科学研究中非常有用，它可以帮助研究人员发现和改正概念上的错误，同时也让他们能够更深入地理解其研究主题。 很多数学家选择使用 Lean 的标准库 mathlib 作为基础，这个仓库被称为 [[https://www.quantamagazine.org/building-the-mathematical-library-of-the-future-20201001/][未来的数学图书馆]]。

**** Lean-zh [[#lean-zh][¶]]


Lean-zh 是一个自发组成的团体，旨在推动 Lean 在中文学术和编程社区的普及和应用。

如果你对 Lean 感兴趣，对编写 Lean 教程、翻译官方文档、开发 Lean 项目，或者任何其他形式的贡献感兴趣，欢迎加入我们。

**** 相关工作 [[#_1][¶]]


***** Lean4 教程 [[#lean4][¶]]


- [[file:tutorial/install/][Lean4 安装教程]]
- [[file:tutorial/lean4game/][Lean4Game 游戏编写教程]]
- [[file:tutorial/lean-dojo/][LeanDojo 使用教程]]

***** 文档翻译 [[#_2][¶]]


- [[https://www.leanprover.cn/GlimpseOfLean/][Lean4 语言初探 //]]
- [[https://www.leanprover.cn/fp-lean-zh/][Lean4 函数式编程 //]]
- [[https://www.leanprover.cn/tp-lean-zh/][Lean4 定理证明 //]]
- [[https://game.leanprover.cn/#/g/local/NNG4][Lean4 自然数游戏 //]]
- [[https://www.leanprover.cn/mp-lean-zh/][Lean4 元编程 //]]

***** 进行中 [[#_3][¶]]


- [[https://github.com/Lean-zh/GlimpseGame][GlimpseToGame 定理证明游戏的制作及翻译]]
- [[https://www.leanprover.cn/math-in-lean-zh/][Lean 形式化数学]]

***** 计划中 [[#_4][¶]]


- Tactic手册及如何编写tactic
- LeanCopliot，LLMStep 等工具教程及实现机制
- ...

***** 相关推荐 [[#_5][¶]]


- 软件基础： [[https://coq-zh.github.io/SF-zh/][Software Foundations]]
- [[https://agda-zh.github.io/PLFA-zh/][编程语言基础：Agda 描述]]

**** 其他链接 [[#_6][¶]]


- Lean-zh 官网: [[https://leanprover.cn]]
- Lean 社区官网: [[https://lean-lang.org]]
- Lean 的 Zulip 社区: [[https://leanprover.zulipchat.com]]
- 自然数游戏: [[https://nng4.leanprover.cn]]

**** 联系我们 [[#_7][¶]]


如果有任何问题、建议或想参与到社区中来，欢迎加入 QQ 群 897971266 或 Telegram [[https://t.me/Lean_zh_CN][讨论组]] 来一起交流。
* [[https://www.leanprover.cn/fp-lean-zh/type-classes/out-params.html][控制实例搜索 - Lean 函数式编程]] :website:

[2024-11-21 Thu 17:17]

** Article

*** [[#控制实例搜索][控制实例搜索]]


要方便地相加两个 =Pos= 类型，并产生另一个 =Pos= ，一个 =Add= 类的的实例就足够了。 但是，在许多情况下，参数可能有不同的类型，重载一个灵活的 *异质* 运算符是更为有用的。 例如，让 =Nat= 和 =Pos= ，或 =Pos= 和 =Nat= 相加总会是一个 =Pos=

#+BEGIN_EXAMPLE
    def addNatPos : Nat → Pos → Pos
      | 0, p => p
      | n + 1, p => Pos.succ (addNatPos n p)

    def addPosNat : Pos → Nat → Pos
      | p, 0 => p
      | p, n + 1 => Pos.succ (addPosNat p n)
#+END_EXAMPLE

这些函数允许自然数与正数相加，但他们不能在 =Add= 类型类中，因为它希望 =add= 的两个参数都有同样的类型。

**** [[#异质重载][异质重载]]


就像在 [[./pos#%E9%87%8D%E8%BD%BD%E5%8A%A0%E6%B3%95][重载加法]]一节提到的，Lean 提供了名为 =HAdd= 的类型类来重载异质加法。 =HAdd= 类接受三个类型参数：两个参数的类型和一个返回类型。 =HAdd Nat Pos Pos= 和 =HAdd Pos Nat Pos= 的实例可以让常规加法符号可以接受不同类型。

#+BEGIN_EXAMPLE
    instance : HAdd Nat Pos Pos where
      hAdd := addNatPos

    instance : HAdd Pos Nat Pos where
      hAdd := addPosNat
#+END_EXAMPLE

有了上面两个实例，就有了下面的例子：

#+BEGIN_EXAMPLE
     #eval (3 : Pos) + (5 : Nat)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
     8
#+END_EXAMPLE

#+BEGIN_EXAMPLE
     #eval (3 : Nat) + (5 : Pos)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
     8
#+END_EXAMPLE

=HAdd= 的定义和下面 =HPlus= 的定义很像。下面是 =HPlus= 和它对应的实例：

#+BEGIN_EXAMPLE
    class HPlus (α : Type) (β : Type) (γ : Type) where
      hPlus : α → β → γ

    instance : HPlus Nat Pos Pos where
      hPlus := addNatPos

    instance : HPlus Pos Nat Pos where
      hPlus := addPosNat
#+END_EXAMPLE

然而， =HPlus= 的实例明显没有 =HAdd= 的实例有用。 当尝试用 =#eval= 使用这些实例时，一个错误就出现了：

#+BEGIN_EXAMPLE
     #eval HPlus.hPlus (3 : Pos) (5 : Nat)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    typeclass instance problem is stuck, it is often due to metavariables
      HPlus Pos Nat ?m.7527
#+END_EXAMPLE

发生错误是因为类型中有元变量，Lean 没办法解决它。

就像我们在 [[../getting-to-know/polymorphism.html][多态一开始的描述]] 里说的那样，元变量代表了程序无法被推断的未知部分。 当一个表达式被写在 =#eval= 后时，Lean 会尝试去自动确定它的类型。 在这种情况下，它无法做到自动确定类型。 因为 =HPlus= 的第三个类型参数依然是未知的，Lean 没办法进行类型类实例搜索，但是实例搜索是 Lean 唯一可能确定表达式的类型的方式。 也就是说， =HPlus Pos Nat Pos= 实例只能在表达式的类型为 =Pos= 时应用，但除了实例本身之外，程序中没有其他东西表明它应该具有这种类型。

一种解决方法是保证全部三个类型都是已知的，通过给整个表达式添加一个类型标记来实现这一点：

#+BEGIN_EXAMPLE
    #eval (HPlus.hPlus (3 : Pos) (5 : Nat) : Pos)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    8
#+END_EXAMPLE

然而，这种解决方式对使用我们的正数库的用户来说并不是很方便。

**** [[#输出参数][输出参数]]

刚才的问题也可以通过声明 =γ= 是一个 *输出参数（output parameter）* 来解决。 多数类型类参数是作为搜索算法的输入：它们被用于选取一个实例。 例如，在 =OfNat= 实例中，类型和自然数都被用于选取一个数字字面量的特定解释。 然而，在一些情况下，在尽管有些类型参数仍然处于未知状态时就开始进行搜索是更方便的。 这样就能使用在搜索中发现的实例来决定元变量的值。 在开始搜索实例时不需要用到的参数就是这个过程的结果，该参数使用 =outParam= 修饰符来声明。

#+BEGIN_EXAMPLE
    class HPlus (α : Type) (β : Type) (γ : outParam Type) where
      hPlus : α → β → γ
#+END_EXAMPLE

有了这个输出参数，类型类实例搜索就能够在不需要知道 =γ= 的情况下选取一个实例了。 例如：

#+BEGIN_EXAMPLE
    #eval HPlus.hPlus (3 : Pos) (5 : Nat)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    8
#+END_EXAMPLE

认为输出参数相当于是定义某种函数在思考时可能会有帮助。 任意给定的，类型类的实例都有一个或更多输出参数提供给 Lean。这能指导 Lean 通过输入（的类型参数）来确定输出（的类型）。 一个可能是递归的实例搜索过程，最终会比简单的重载更为强大。 输出参数能够决定程序中的其他类型，实例搜索能够将一族附属实例组合成具有这种类型的程序。

**** [[#默认实例][默认实例]]


确定一个参数是否是一个输入或输出参数控制了 Lean 会在何时启动类型类搜索。 具体而言，直到所有输入都变为已知，类型类搜索才会开始。 然而，在一些情况下，输出参数是不足的。此时，即使一些输入参数仍然处于未知状态，实例搜索也应该开始。 这有点像是 Python 或 Kotlin 中可选函数参数的默认值，但在这里是默认 *类型* 。

*默认实例* 是 *当并不是全部输入均为已知时* 可用的实例。 当一个默认实例能被使用时，他就将会被使用。 这能帮助程序成功通过类型检查，而不是因为关于未知类型和元变量的错误而失败。 但另一方面，默认类型会让实例选取变得不那么可预测。 具体而言，如果一个不合适的实例被选取了，那么表达式将可能具有和预期不同的类型。 这会导致令人困惑的类型错误发生在程序中。 明智地选择要使用默认实例的地方！

默认实例可以发挥作用的一个例子是可以从 =Add= 实例派生出的 =HPlus= 实例。 换句话说，常规的加法是异质加法在三个参数类型都相同时的特殊情况。 这可以用下面的实例来实现：

#+BEGIN_EXAMPLE
    instance [Add α] : HPlus α α α where
      hPlus := Add.add
#+END_EXAMPLE

有了这个实例， =hPlus= 就可以被用于任何可加的类型，就像 =Nat=：

#+BEGIN_EXAMPLE
    #eval HPlus.hPlus (3 : Nat) (5 : Nat)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
    8
#+END_EXAMPLE

然而，这个实例只会用在两个参数类型都已知的情况下。 例如：

#+BEGIN_EXAMPLE
    #check HPlus.hPlus (5 : Nat) (3 : Nat)
#+END_EXAMPLE

产生类型

#+BEGIN_EXAMPLE
    HPlus.hPlus 5 3 : Nat
#+END_EXAMPLE

就像我们预想的那样，但是

#+BEGIN_EXAMPLE
    #check HPlus.hPlus (5 : Nat)
#+END_EXAMPLE

产生了一个包含剩余参数和返回值类型的两个元变量的类型：

#+BEGIN_EXAMPLE
    HPlus.hPlus 5 : ?m.7706 → ?m.7708
#+END_EXAMPLE

在绝大多数情况下，当提供一个加法参数时，另一个参数也会是同一个类型。 来让这个实例成为默认实例，应用 =default_instance= 属性：

#+BEGIN_EXAMPLE
    @[default_instance]
    instance [Add α] : HPlus α α α where
      hPlus := Add.add
#+END_EXAMPLE

有了默认实例，这个例子就有了更有用的类型：

#+BEGIN_EXAMPLE
    #check HPlus.hPlus (5 : Nat)
#+END_EXAMPLE

结果为：

#+BEGIN_EXAMPLE
    HPlus.hPlus 5 : Nat → Nat
#+END_EXAMPLE

每个同时重载了异质和同质运算的运算符，都能在默认实例需要异质运算的语境中使用同质运算。 中缀运算符会被替换为异质运算，并且在需要时尽可能选择同质的默认实例。

简单来说，简单地写 =5= 会给出一个 =Nat= 而不是一个需要更多信息来选取 =OfNat= 实例的一个包含元变量的类型。 这是因为 =OfNat= 以 =Nat= 作为默认实例。

默认实例也可以被赋予 *优先级* ，这会影响在可能的应用多于一种的情况下的选择。 更多关于默认实例优先级的信息，请查阅 Lean 手册。

**** [[#练习][练习]]


定义一个 =HMul (PPoint α) α (PPoint α)= 的实例，该实例将两个投影都乘以标量。 它应适用于任何存在 =Mul α= 实例的类型 =α=。例如：

#+BEGIN_EXAMPLE
    #eval {x := 2.5, y := 3.7 : PPoint Float} * 2.0
#+END_EXAMPLE

结果应为

#+BEGIN_EXAMPLE
    { x := 5.000000, y := 7.400000 }
#+END_EXAMPLE
